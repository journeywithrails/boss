module InvoiceParts
  module InvoiceFilters
      def status_filters
        %w{draft sent unsent paid unpaid}.collect do |s|
          o=OpenStruct.new
          o.value = s
          o.name = s.titleize
          o
        end
      end

      def find_by_meta_status_conditions(the_meta_status)
        conditions = ""
        case the_meta_status
        when Invoice::META_STATUS_PAST_DUE
          conditions = "invoices.status in ('sent','resent', 'changed', 'acknowledged') and ((invoices.due_date < '#{Date.today.to_s(:db)}') and (invoices.due_date is not null))"
        when Invoice::META_STATUS_DRAFT
          conditions = "invoices.status in ('draft', 'printed')" 
        when Invoice::META_STATUS_OUTSTANDING
          conditions = "invoices.status in ('sent','resent', 'changed', 'acknowledged') and ((invoices.due_date >= '#{Date.today.to_s(:db)}') or (invoices.due_date is null))"
        when Invoice::META_STATUS_QUOTE
          conditions = "invoices.status in ('quote_draft','quote_sent') and ((invoices.due_date >= '#{Date.today.to_s(:db)}') or (invoices.due_date is null))"
        when Invoice::META_STATUS_PAID
          conditions = "invoices.status = 'paid'"
        else
          return nil
        end
        conditions
      end

      # returns list of invoices from parent, filtered according to filters. Returns a summary row for 
      # those invoices if add_summary is true. _filters_ is expected to be an object, for example the
      # OpenStruct returned by Application#setup_search_filters. Sql conditions can be added to the ones
      # that will be generated by the filters by adding filters.conditions = _some_sql_. Options for 
      # the underlying find, including pagination options, can be set in filters.options
      def filtered_invoices(parent, filters, add_summary=false)
        # if the 'unique' filter is set, pre-emptively find the one invoice with that unique
        unless filters.unique.blank?
          i = find_by_unique(filters.unique)
          return [i] unless i.nil?
        end

        conditions = []

        # add any custom conditions to the conditions
        if filters.conditions
          conditions << filters.conditions
        end
        
        # add search by customer(s)
        if filters.customers and !filters.customers.empty?
          conditions << "customer_id in (#{filters.customers.map(&:to_i).join(',')})"
        end

        # add search for invoices after _fromdate_
        if filters.fromdate and !filters.fromdate.empty?
          # the date is in yyyy-mm-dd format 
          # the calendar control has is set to this format
          conditions << sanitize_sql_array(['date >= ?',filters.fromdate])
        end

        # add search for invoices before _todate_
        if filters.todate and !filters.todate.empty?
          conditions << sanitize_sql_array(['date <= ?', filters.todate])
        end
        
        # add search by currency
        if filters.currency and !filters.currency.empty?
          if parent.currency_exists?(filters.currency)
            conditions << sanitize_sql_array(['currency = ?', filters.currency]) 
          elsif !parent.first_fallback.nil?
            conditions << sanitize_sql_array(['currency = ?', parent.first_fallback.currency])
          end
        end         
        
        if filters.invoice_type and !filters.invoice_type.blank?
          if filters.invoice_type == 'Invoice'
            conditions << 'invoices.type is null'
          else
            conditions << sanitize_sql_array(['invoices.type = ?', filters.invoice_type])
          end
        end

        # add search for invoices by 'metastatus'
        if filters.statuses and !filters.statuses.empty?
          in_statuses = get_statuses_for_filtering(filters.statuses)
          conditions << "status in(#{in_statuses.uniq.join(',')})"
        else
          if filters.exclude and !filters.exclude.empty?
            in_statuses = get_statuses_for_filtering(filters.exclude)
            conditions << "status NOT in(#{in_statuses.uniq.join(',')})"
          end
        end    

        conditions << "status!='superceded'"

        condition_str = conditions.empty? ? nil : '(' + conditions.join(') AND (') + ')'

        options = filters.options || {}
        options[:page] = filters.page

        invoices, summary = nil

        # use with_scope to do a paginated find within our conditions
        Invoice.with_scope(:find => {:conditions => condition_str}) do
          invoices = parent.find( :all, options)
          if add_summary

            summary = parent.find(:first, :select => "count(id),
            sum(total_amount) as total_amount,
            sum(discount_amount) as discount_amount,
            sum(tax_1_amount) as tax_1_amount,
            sum(tax_2_amount) as tax_2_amount,
            sum(subtotal_amount) as subtotal_amount,
            sum(paid_amount) as paid_amount,
            sum(owing_amount) as owing_amount").attributes
          end
        end
        return add_summary ? [invoices, summary] : invoices        
      end

      def filtered_invoices_with_summary(parent, filters)
        Invoice.filtered_invoices(parent, filters, true)
      end

      def filtered_invoices_with_summary_as_json(parent, filters, json_params)
        return_data = Hash.new()
        return_data[:invoices], return_data[:summary] = Invoice.filtered_invoices_with_summary(parent, filters)
        return_data[:total] = return_data[:invoices].size
        json = return_data.to_json({:pass_options => {:invoices => json_params}})
        json
      end

      def get_statuses_for_filtering statuses
        in_statuses = []
        if statuses.include?('draft')
          in_statuses << "'draft'"
          in_statuses << "'printed'"
        end
        if statuses.include?('sent')
          in_statuses << "'sent'"
          in_statuses << "'resent'"
        end
        if statuses.include?('paid')
          in_statuses << "'paid'"
        end
        if statuses.include?('unpaid')
          in_statuses << "'draft'"
          in_statuses << "'printed'"
          in_statuses << "'sent'"
          in_statuses << "'resent'"
          in_statuses << "'changed'"
        end
        if statuses.include?('unsent')
          in_statuses << "'draft'"
          in_statuses << "'printed'"
          in_statuses << "'changed'"
        end
        if statuses.include?('quote')
          in_statuses << "'quote_draft'"
          in_statuses << "'quote_sent'"
        end
        if statuses.include?('recurring')
          in_statuses << "'recurring'"
        end
        in_statuses
      end

  end
end
    
