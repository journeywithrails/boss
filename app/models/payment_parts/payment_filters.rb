module PaymentParts
  module PaymentFilters

    # returns list of invoices from parent, filtered according to filters. Returns a summary row for 
    # those invoices if add_summary is true. _filters_ is expected to be an object, for example the
    # OpenStruct returned by Application#setup_search_filters. Sql conditions can be added to the ones
    # that will be generated by the filters by adding filters.conditions = _some_sql_. Options for 
    # the underlying find, including pagination options, can be set in filters.options
    # returns list of invoices from parent, filtered according to filters. Returns a summary row for 
    # those invoices if add_summary is true. _filters_ is expected to be an object, for example the
    # OpenStruct returned by Application#setup_search_filters. Sql conditions can be added to the ones
    # that will be generated by the filters by adding filters.conditions = _some_sql_. Options for 
    # the underlying find, including pagination options, can be set in filters.options
    def filtered_payments(parent, filters, add_summary=false)
      # if the 'unique' filter is set, pre-emptively find the one invoice with that unique
      unless filters.unique.blank?
        i = find_by_unique(filters.unique)
        return [i] unless i.nil?
      end

      conditions = []

      # add any custom conditions to the conditions
      if filters.conditions
        conditions << filters.conditions
      end

conditions <<"payments.status='recorded' or payments.status='cleared'"
      # add search by customer(s)
      if filters.customers and !filters.customers.empty?
        conditions << "payments.customer_id in (#{filters.customers.map(&:to_i).join(',')})"
      end

      # add search for invoices after _fromdate_
      if filters.fromdate and !filters.fromdate.empty?
        # the date is in yyyy-mm-dd format 
        # the calendar control has is set to this format
        conditions << sanitize_sql_array(['payments.date >= ?',filters.fromdate])
      end

      # add search for invoices before _todate_
      if filters.todate and !filters.todate.empty?
        conditions << sanitize_sql_array(['payments.date <= ?', filters.todate])
      end
      
      # search by currency, fallback if doesn't exist
      if filters.currency and !filters.currency.empty?          
        if parent.currency_exists?(filters.currency)
          conditions << sanitize_sql_array(['invoices.currency = ?', filters.currency])
        elsif !parent.first_fallback_currency.blank?
          conditions << sanitize_sql_array(['invoices.currency = ?', parent.first_fallback_currency]) 
        end
      end
            
      condition_str = conditions.empty? ? nil : '(' + conditions.join(') AND (') + ')'

      options = filters.options || {}
      options[:page] = filters.page

      payments, summary, paytotals = nil

      # use with_scope to do a paginated find within our conditions
      Payment.with_scope(:find => {:include => :invoices, :conditions => condition_str}) do
        payments = parent.find( :all, options)
        
        if add_summary

          #summary = parent.find(:first, :select => "sum(amount) as amount").attributes
          summary = {}
          summary["amount"] = parent.map(&:amount).sum
          
          pay_types_and_totals = Hash.new
          parent.find(:all).group_by(&:pay_type_display).each do |key,values|
            pay_types_and_totals[key] = sprintf("%.2f", values.map(&:amount).sum.to_f)
          end
          paytotals = pay_types_and_totals
        end
      end
      return add_summary ? [payments, summary, paytotals] : payments
    end

    def filtered_payments_with_summary(parent, filters)
      Payment.filtered_payments(parent, filters, true)
    end

    def filtered_payments_with_summary_as_json(parent, filters, json_params)
      return_data = Hash.new()
      return_data[:payments], return_data[:summary], return_data[:paytotals] = Payment.filtered_payments_with_summary(parent, filters)
      return_data[:total] = return_data[:payments].size
      json = return_data.to_json({:pass_options => {:payments => json_params}})
      json
    end
    
  end
end
